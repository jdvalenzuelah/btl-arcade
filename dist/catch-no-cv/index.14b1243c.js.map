{"mappings":"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","sources":["src/catch-no-cv/catch.js"],"sourcesContent":["const gamejs = require('gamejs')\nconst pixelcollision = require('gamejs/src/gamejs/pixelcollision')\nconst vectors = require('gamejs/src/gamejs/math/vectors')\n\n\nclass Catch {\n\n    #deathCallback = function() {}\n    #winCallback = function() {}\n    #font = new gamejs.font.Font('200px monospace');\n    constructor(config, resources) {\n        this.config = config\n        this.resources = resources\n        this.#resetState()\n    }\n\n    #resetState() {\n        this.state = {\n            started: false,\n            elapsedMs: 0,\n            remainingLives: this.config.game.lives,\n            background: undefined,\n            catcher: undefined,\n            lives: [],\n            fallingItems: [],\n            speed: this.config.game.fallSpeed.initial,\n            score: 0,\n            level: 1,\n            itemsToSpawn: this.config.game.fallingItems.initial,\n            lastItemSpawnLevelUp: 1,\n        }\n    }\n\n    setup() {\n        this.display = gamejs.display.getSurface()\n        this.size = this.display.getSize()\n        this.background = {\n            bg: gamejs.image.load(this.resources.background).scale(this.size),\n        }\n\n        this.state.background = this.background.bg\n    }\n\n    start() {\n        if(this.state.started) {\n            console.warn('Game alredy started!')\n            return\n        }\n\n        this.state.started = true\n\n        let catcherImg = gamejs.image.load(this.resources.catcher).scale(this.config.catcherSize)\n        this.state.catcher = {\n            img: catcherImg,\n            pos: [0, this.size[1] - 300],\n            mask: new pixelcollision.Mask(catcherImg)\n        }\n\n        for(let i =  0; i < this.state.remainingLives; i++) {\n            let x = (this.config.livesSize[1] * i) + 400\n            this.state.lives.push({\n                img: gamejs.image.load(this.resources.lives).scale(this.config.livesSize),\n                pos: [x, 20]\n            })\n        }\n\n        this.#spawnItem()\n    }\n\n    reset() {\n        this.#resetState()\n        this.setup()\n    }\n    \n    #lastEpoch = new Date().getTime()\n\n    onTick(msDuration) {\n        let newEpoch = new Date().getTime()\n        let diff = newEpoch - this.#lastEpoch\n        this.#lastEpoch = newEpoch\n    \n        if(diff < 15) {\n            return\n        }\n\n        this.state.elapsedMs += msDuration;\n        this.display.clear()\n\n        this.display.blit(this.state.background, [0, 0])\n        \n        this.display.blit(this.#font.render(`${this.state.score}`, '#fcecd3'), [this.size[0] - 200, 120]);\n\n        if(this.state.started) {\n            if(this.state.lives) {\n                this.state.lives.forEach(live => {\n                    this.display.blit(live.img, live.pos)    \n                });\n            }\n    \n            if(this.state.catcher) {\n                this.display.blit(this.state.catcher.img, this.state.catcher.pos)\n            }\n    \n            if(this.state.fallingItems) {\n\n                this.state.fallingItems.forEach((item, idx) => {\n                    item.pos = vectors.add(item.pos, [0, this.state.speed]);\n                    this.display.blit(item.img, item.pos)\n    \n                    if(this.#reachBottom(item.pos)) {\n                        this.state.fallingItems.splice(idx, 1)\n                        this.#die()\n                        if(this.state.remainingLives > 0) {\n                            this.#spawnItem()\n                        }\n                    }\n\n                    if(this.#recolected(item)) {\n                        this.state.fallingItems.splice(idx, 1)\n                        this.state.score++\n                        \n                        if(this.state.fallingItems.length === 0) {\n                            this.#spawnItem()\n                        }\n                    }\n                })\n            }\n    \n            this.#maybeLevelUp()\n            this.#checkWin()\n        }\n    }\n\n    #reachBottom(pos) {\n        return pos[1] >= this.size[1];\n    }\n\n    #recolected(item) {\n        if(this.state.catcher) {\n            let relativeOffset = vectors.subtract(this.state.catcher.pos, item.pos)\n            let hasMaskOverlap = this.state.catcher.mask.overlap(item.mask, relativeOffset)\n\n            return hasMaskOverlap\n        }\n\n        return false\n    }\n\n    #die() {\n        if(this.state.lives.length)\n            this.state.lives.splice(this.state.lives.length -1, 1)\n        this.state.remainingLives -= 1;\n\n        if(this.state.remainingLives === 0) {\n            this.#kill()\n        }\n    }\n\n    #spawnItem() {\n        if(this.state.fallingItems.length >= this.config.game.fallingItems.max)\n            return\n        \n        for(let i = 0; i < this.state.itemsToSpawn; i++) {\n            if(this.state.fallingItems.length >= this.config.game.fallingItems.max)\n                return\n\n            let imgR = this.resources.fallingItems[Math.floor(Math.random()*this.resources.fallingItems.length)]\n        \n            let img = gamejs.image.load(imgR).scale(this.config.fallingItemsSize)\n    \n            this.state.fallingItems.push({\n                img: img,\n                pos: [Math.floor(Math.random() * (this.size[0] - this.config.fallingItemsSize[0])), 0],\n                mask: new pixelcollision.Mask(img)\n            })\n        }\n    }\n\n    #maybeLevelUp() {\n        let minElapsed = this.state.level * this.config.game.levelUpMs\n\n        let nextLevel = this.state.level + 1\n        if(this.state.elapsedMs >= minElapsed) {\n            this.state.level = nextLevel\n            this.state.speed = Math.min(this.state.speed+this.config.game.fallSpeed.step, this.config.game.fallSpeed.max)\n        }\n\n        if((this.state.level - this.state.lastItemSpawnLevelUp) >= this.config.game.fallingItems.levelUpStep) {\n            this.state.lastItemSpawnLevelUp = nextLevel\n            this.state.itemsToSpawn = Math.min(this.state.itemsToSpawn+this.config.game.fallingItems.step, this.config.game.fallingItems.max)\n        }\n    }\n\n    #kill() {\n        this.started = false;\n        this.#deathCallback()\n        this.#resetState()\n        this.setup()\n    }\n\n    #checkWin() {\n        if(this.state.score >= this.config.game.winScore) {\n            this.started = false;\n            this.#winCallback()\n            this.#resetState()\n            this.setup()\n        }\n    }\n\n    onDeath(fn) {\n        this.#deathCallback = fn\n    }\n\n    onWin(fn) {\n        this.#winCallback = fn\n    }\n\n    moveCatcher(avgXPos) {\n        if(this.state.catcher)\n            this.state.catcher.pos[0] = Math.floor(this.size[0] * (1 - avgXPos))\n    }\n\n    moveCatcherStep(step) {\n        if(this.state.catcher) {\n            let newPos = Math.min(Math.max(0, this.state.catcher.pos[0] + step), this.size[0] - this.config.catcherSize[0])\n            this.state.catcher.pos[0] = newPos\n        }\n    }\n\n    moveCatcherMotion(pos) {\n        if(this.display.rect.collidePoint(pos)) {\n            this.state.catcher.pos[0] =  Math.min(Math.max(0, pos[0]), this.size[0] - this.config.catcherSize[0])\n        }\n    }\n}\n\nconst gameConfig = loadConfig('catch-no-cv', config);\n\nlet running = false;\n\nconst game = new Catch(gameConfig, resources)\n\nfunction hide(id) {\n    document.getElementById(id)\n        .classList.add(\"hidden\")  \n}\n\nfunction show(id) {\n    document.getElementById(id)\n        .classList.remove(\"hidden\")  \n}\n\nfunction destroy(id) {\n    document.getElementById(id).remove()\n}\n\nfunction startGame() {\n    running = true;\n    gamejs.preload([\n        resources.background,\n        resources.catcher,\n        resources.lives,\n        ...resources.fallingItems\n    ])\n\n    gamejs.event.onKeyDown(function(event) {\n        if(event.key === gamejs.event.K_LEFT) {\n            game.moveCatcherStep(-20)\n        }\n\n        if(event.key === gamejs.event.K_RIGHT) {\n            game.moveCatcherStep(20)\n        }\n    })\n\n    gamejs.event.onMouseMotion(function(event) {\n        game.moveCatcherMotion(event.pos)\n    })\n\n    gamejs.event.onTouchMotion(function(event) {\n        game.moveCatcherMotion(event.touches[0].pos)\n    })\n\n    gamejs.ready(function () {\n        hide('idle')\n        show('game')\n\n        gamejs.onTick(function(msDuration) {\n            game.onTick(msDuration)\n        })\n    \n        game.onDeath(function() { died() })\n        game.onWin(function() { win() })\n    \n        game.reset()\n        game.start()\n    })\n}\n\nfunction died() {\n    show('lose')\n    hide('game')\n    game.reset()\n\n    setTimeout(() => {\n        location.reload()\n    }, config.loseCooldownMs)\n}\n\nfunction win() {\n    show('win')\n    hide('game')\n    \n    game.reset()\n    running = false\n\n    setTimeout(() => {\n        location.reload()\n    }, gameConfig.winCooldownMs)\n}\n\ndocument.getElementById('start').addEventListener('click', (e) => {\n    if(!running)\n        startGame()\n});\n\ndocument.getElementById('start-text').addEventListener('click', (e) => {\n    if(!running)\n        startGame()\n});\n\n"],"names":["gamejs","require","pixelcollision","vectors","gameConfig","loadConfig","config","running","game","deathCallback","winCallback","font","Font","constructor","config1","resources1","this","resources","resetState","state","started","elapsedMs","remainingLives","lives","background","undefined","catcher","fallingItems","speed","fallSpeed","initial","score","level","itemsToSpawn","lastItemSpawnLevelUp","setup","display","getSurface","size","getSize","bg","image","load","scale","start","console","warn","catcherImg","catcherSize","img","pos","mask","Mask","i","x","livesSize","push","spawnItem","reset","lastEpoch","Date","getTime","onTick","msDuration","newEpoch","diff","clear","blit","render","forEach","live","item","idx","add","reachBottom","splice","die","recolected","length","maybeLevelUp","checkWin","relativeOffset","subtract","overlap","kill","max","imgR","Math","floor","random","fallingItemsSize","minElapsed","levelUpMs","nextLevel","min","step","levelUpStep","winScore","onDeath","fn","onWin","moveCatcher","avgXPos","moveCatcherStep","newPos","moveCatcherMotion","rect","collidePoint","hide","id","document","getElementById","classList","show","remove","startGame","preload","event","onKeyDown","key","K_LEFT","K_RIGHT","onMouseMotion","onTouchMotion","touches","ready","setTimeout","location","reload","loseCooldownMs","winCooldownMs","addEventListener","e"],"version":3,"file":"index.14b1243c.js.map"}