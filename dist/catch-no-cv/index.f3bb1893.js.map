{"mappings":"usCAAA,MAAMA,EAASC,EAAQ,oBACjBC,EAAiBD,EAAQ,oBACzBE,EAAUF,EAAQ,oBAqRxB,MAAMG,EAAaC,WAAW,cAAeC,QAE7C,IAAIC,GAAU,EAEd,MAAMC,EAAO,IAtRb,MAEIC,GAAiB,WAAY,EAC7BC,GAAe,WAAY,EAC3BC,GAAQ,IAAIX,EAAOW,KAAKC,KAAK,mBAC7BC,YAAYC,EAAQC,GAChBC,KAAKV,OAASQ,EACdE,KAAKC,UAAYF,EACjBC,MAAKE,GACT,CAEAA,KACIF,KAAKG,MAAQ,CACTC,SAAS,EACTC,UAAW,EACXC,eAAgBN,KAAKV,OAAOE,KAAKe,MACjCC,gBAAYC,EACZC,aAASD,EACTF,MAAO,GACPI,aAAc,GACdC,MAAOZ,KAAKV,OAAOE,KAAKqB,UAAUC,QAClCC,MAAO,EACPC,MAAO,EACPC,aAAcjB,KAAKV,OAAOE,KAAKmB,aAAaG,QAC5CI,qBAAsB,EACtBC,UAAW,KAEnB,CAEAC,QACIpB,KAAKqB,QAAUrC,EAAOqC,QAAQC,aAC9BtB,KAAKuB,KAAOvB,KAAKqB,QAAQG,UACzBxB,KAAKQ,WAAa,CACdiB,GAAIzC,EAAO0C,MAAMC,KAAK3B,KAAKC,UAAUO,YAAYoB,MAAM5B,KAAKuB,OAGhEvB,KAAKG,MAAMK,WAAaR,KAAKQ,WAAWiB,EAC5C,CAEAI,QACI,GAAG7B,KAAKG,MAAMC,QAEV,YADA0B,QAAQC,KAAK,wBAIjB/B,KAAKG,MAAMC,SAAU,EAErB,IAAI4B,EAAahD,EAAO0C,MAAMC,KAAK3B,KAAKC,UAAUS,SAASkB,MAAM5B,KAAKV,OAAO2C,aAC7EjC,KAAKG,MAAMO,QAAU,CACjBwB,IAAKF,EACLG,IAAK,CAAC,EAAGnC,KAAKuB,KAAK,GAAK,KACxBa,KAAM,IAAIlD,EAAemD,KAAKL,IAGlC,IAAI,IAAIM,EAAK,EAAGA,EAAItC,KAAKG,MAAMG,eAAgBgC,IAAK,CAChD,IAAIC,EAAIvC,KAAMV,OAAOkD,UAAU,GAAKF,EAAK,IACzCtC,KAAKG,MAAMI,MAAMkC,KAAK,CAClBP,IAAKlD,EAAO0C,MAAMC,KAAK3B,KAAKC,UAAUM,OAAOqB,MAAM5B,KAAKV,OAAOkD,WAC/DL,IAAK,CAACI,EAAG,KAEjB,CAEAvC,MAAK0C,GACT,CAEAC,QACI3C,MAAKE,IACLF,KAAKoB,OACT,CAEAwB,IAAa,IAAIC,MAAOC,UAExBC,OAAOC,GACH,IAAIC,GAAW,IAAIJ,MAAOC,UACtBI,EAAOD,EAAWjD,MAAK4C,EAC3B5C,MAAK4C,EAAaK,EAEfC,EAAO,KAIVlD,KAAKG,MAAME,WAAa2C,EACxBhD,KAAKqB,QAAQ8B,QAEbnD,KAAKqB,QAAQ+B,KAAKpD,KAAKG,MAAMK,WAAY,CAAC,EAAG,IAE7CR,KAAKqB,QAAQ+B,KAAKpD,MAAKL,EAAM0D,OAAO,GAAGrD,KAAKG,MAAMY,QAAS,WAAY,CAACf,KAAKuB,KAAK,GAAK,IAAK,MAEzFvB,KAAKG,MAAMC,UACPJ,KAAKG,MAAMI,OACVP,KAAKG,MAAMI,MAAM+C,SAAQC,IACrBvD,KAAKqB,QAAQ+B,KAAKG,EAAKrB,IAAKqB,EAAKpB,IAAG,IAIzCnC,KAAKG,MAAMO,SACVV,KAAKqB,QAAQ+B,KAAKpD,KAAKG,MAAMO,QAAQwB,IAAKlC,KAAKG,MAAMO,QAAQyB,KAG9DnC,KAAKG,MAAMQ,cAEVX,KAAKG,MAAMQ,aAAa2C,SAAQ,CAACE,EAAMC,KACnCD,EAAKrB,IAAMhD,EAAQuE,IAAIF,EAAKrB,IAAK,CAAC,EAAGnC,KAAKG,MAAMS,QAChDZ,KAAKqB,QAAQ+B,KAAKI,EAAKtB,IAAKsB,EAAKrB,KAE9BnC,MAAK2D,EAAaH,EAAKrB,OACtBnC,KAAKG,MAAMQ,aAAaiD,OAAOH,EAAK,GACpCzD,MAAK6D,IACF7D,KAAKG,MAAMG,eAAiB,GAC3BN,MAAK0C,KAIV1C,MAAK8D,EAAYN,KAChBxD,KAAKG,MAAMQ,aAAaiD,OAAOH,EAAK,GACpCzD,KAAKG,MAAMY,QAE2B,IAAnCf,KAAKG,MAAMQ,aAAaoD,QACvB/D,MAAK0C,IAEb,IAIR1C,MAAK0C,IACL1C,MAAKgE,IACLhE,MAAKiE,KAEb,CAEAN,GAAaxB,GACT,OAAOA,EAAI,IAAMnC,KAAKuB,KAAK,EAC/B,CAEAuC,GAAYN,GACR,GAAGxD,KAAKG,MAAMO,QAAS,CACnB,IAAIwD,EAAiB/E,EAAQgF,SAASnE,KAAKG,MAAMO,QAAQyB,IAAKqB,EAAKrB,KAGnE,OAFqBnC,KAAKG,MAAMO,QAAQ0B,KAAKgC,QAAQZ,EAAKpB,KAAM8B,EAGpE,CAEA,OAAO,CACX,CAEAL,KACO7D,KAAKG,MAAMI,MAAMwD,QAChB/D,KAAKG,MAAMI,MAAMqD,OAAO5D,KAAKG,MAAMI,MAAMwD,OAAQ,EAAG,GACxD/D,KAAKG,MAAMG,gBAAkB,EAEI,IAA9BN,KAAKG,MAAMG,gBACVN,MAAKqE,GAEb,CAEA3B,KACI,GAAG1C,KAAKG,MAAMQ,aAAaoD,QAAU/D,KAAKV,OAAOE,KAAKmB,aAAa2D,IAC/D,OAEJ,IAAIC,GAAM,IAAI1B,MAAOC,UAErB,GAAG9C,KAAKG,MAAMgB,UAAW,CACrB,IAAI+B,EAAOqB,EAAMvE,KAAKG,MAAMgB,UAC5B,GAAGnB,KAAKV,OAAOE,KAAKmB,aAAa6D,kBAAoBtB,EAAM,MAC/D,CAEA,IAAI,IAAIZ,EAAI,EAAGA,EAAItC,KAAKG,MAAMc,aAAcqB,IAAK,CAC7C,GAAGtC,KAAKG,MAAMQ,aAAaoD,QAAU/D,KAAKV,OAAOE,KAAKmB,aAAa2D,IAC/D,OAEJtE,KAAKG,MAAMgB,WAAY,IAAI0B,MAAOC,UAElC,IAAI2B,EAAOzE,KAAKC,UAAUU,aAAa+D,KAAKC,MAAMD,KAAKE,SAAS5E,KAAKC,UAAUU,aAAaoD,SAExF7B,EAAMlD,EAAO0C,MAAMC,KAAK8C,GAAM7C,MAAM5B,KAAKV,OAAOuF,kBAKhDC,EAAc,IAAI5F,EAAemD,KAAKH,GACtC6C,EAAW/E,MAAKgF,EAAaF,GAEjC9E,KAAKG,MAAMQ,aAAa8B,KAAK,CACzBP,IAAKA,EACLC,IAAK4C,EACL3C,KAAM0C,GAEd,CACJ,CAEAE,GAAaF,GACT,IAAIG,GAAwB,EACxBF,EAAW/E,MAAKkF,EAAelF,KAAKV,OAAOuF,iBAAiB,IAEhE,IAAI,IAAIM,EAAK,EAAGA,EAAInF,KAAKG,MAAMQ,aAAaoD,OAAQoB,IAAK,CACrD,IAAI3B,EAAOxD,KAAKG,MAAMQ,aAAawE,GAC/BjB,EAAiB/E,EAAQgF,SAASY,EAAUvB,EAAKrB,KAEhCnC,KAAKG,MAAMO,QAAQ0B,KAAKgC,QAAQU,EAAaZ,KAG9De,GAAwB,EAEhC,CAEA,OAAGA,EACQjF,MAAKgF,EAAaF,GAElBC,CAEf,CAEAG,GAAeE,GACX,MAAO,CAACV,KAAKC,MAAMD,KAAKE,UAAY5E,KAAKuB,KAAK,GAAK6D,IAAa,EACpE,CAEApB,KACI,IAAIqB,EAAarF,KAAKG,MAAMa,MAAQhB,KAAKV,OAAOE,KAAK8F,UAEjDC,EAAYvF,KAAKG,MAAMa,MAAQ,EAChChB,KAAKG,MAAME,WAAagF,IACvBrF,KAAKG,MAAMa,MAAQuE,EACnBvF,KAAKG,MAAMS,MAAQ8D,KAAKc,IAAIxF,KAAKG,MAAMS,MAAMZ,KAAKV,OAAOE,KAAKqB,UAAU4E,KAAMzF,KAAKV,OAAOE,KAAKqB,UAAUyD,MAG1GtE,KAAMG,MAAMa,MAAQhB,KAAKG,MAAMe,sBAAyBlB,KAAKV,OAAOE,KAAKmB,aAAa+E,cACrF1F,KAAKG,MAAMe,qBAAuBqE,EAG1C,CAEAlB,KACIrE,KAAKI,SAAU,EACfJ,MAAKP,IACLO,MAAKE,IACLF,KAAKoB,OACT,CAEA6C,KACOjE,KAAKG,MAAMY,OAASf,KAAKV,OAAOE,KAAKmG,WACpC3F,KAAKI,SAAU,EACfJ,MAAKN,IACLM,MAAKE,IACLF,KAAKoB,QAEb,CAEAwE,QAAQC,GACJ7F,MAAKP,EAAiBoG,CAC1B,CAEAC,MAAMD,GACF7F,MAAKN,EAAemG,CACxB,CAEAE,YAAYC,GACLhG,KAAKG,MAAMO,UACVV,KAAKG,MAAMO,QAAQyB,IAAI,GAAKuC,KAAKC,MAAM3E,KAAKuB,KAAK,IAAM,EAAIyE,IACnE,CAEAC,gBAAgBR,GACZ,GAAGzF,KAAKG,MAAMO,QAAS,CACnB,IAAIwF,EAASxB,KAAKc,IAAId,KAAKJ,IAAI,EAAGtE,KAAKG,MAAMO,QAAQyB,IAAI,GAAKsD,GAAOzF,KAAKuB,KAAK,GAAKvB,KAAKV,OAAO2C,YAAY,IAC5GjC,KAAKG,MAAMO,QAAQyB,IAAI,GAAK+D,CAChC,CACJ,CAEAC,kBAAkBhE,GACXnC,KAAKqB,QAAQ+E,KAAKC,aAAalE,KAC9BnC,KAAKG,MAAMO,QAAQyB,IAAI,GAAMuC,KAAKc,IAAId,KAAKJ,IAAI,EAAGnC,EAAI,IAAKnC,KAAKuB,KAAK,GAAKvB,KAAKV,OAAO2C,YAAY,IAE1G,GAOmB7C,EAAYa,WAEnC,SAASqG,EAAKC,GACVC,SAASC,eAAeF,GACnBG,UAAUhD,IAAI,SACvB,CAEA,SAASiD,EAAKJ,GACVC,SAASC,eAAeF,GACnBG,UAAUE,OAAO,SAC1B,CAMA,SAASC,IACLtH,GAAU,EACVP,EAAO8H,QAAQ,CACX7G,UAAUO,WACVP,UAAUS,QACVT,UAAUM,SACPN,UAAUU,eAGjB3B,EAAO+H,MAAMC,WAAU,SAASD,GACzBA,EAAME,MAAQjI,EAAO+H,MAAMG,QAC1B1H,EAAKyG,iBAAgB,IAGtBc,EAAME,MAAQjI,EAAO+H,MAAMI,SAC1B3H,EAAKyG,gBAAgB,GAE7B,IAEAjH,EAAO+H,MAAMK,eAAc,SAASL,GAChCvH,EAAK2G,kBAAkBY,EAAM5E,IACjC,IAEAnD,EAAO+H,MAAMM,eAAc,SAASN,GAChCvH,EAAK2G,kBAAkBY,EAAMO,QAAQ,GAAGnF,IAC5C,IAEAnD,EAAOuI,OAAM,WACTjB,EAAK,QACLK,EAAK,QAEL3H,EAAO+D,QAAO,SAASC,GACnBxD,EAAKuD,OAAOC,EAChB,IAEAxD,EAAKoG,SAAQ,WASjBe,EAAK,QACLL,EAAK,QACL9G,EAAKmD,QAEL6E,YAAW,KACPC,SAASC,QAAM,GAChBpI,OAAOqI,eAf2B,IACjCnI,EAAKsG,OAAM,WAkBfa,EAAK,OACLL,EAAK,QAEL9G,EAAKmD,QACLpD,GAAU,EAEViI,YAAW,KACPC,SAASC,QAAM,GAChBtI,EAAWwI,cA1BoB,IAE9BpI,EAAKmD,QACLnD,EAAKqC,OACT,GACJ,CAwBA2E,SAASC,eAAe,SAASoB,iBAAiB,SAAUC,IACpDvI,GACAsH,GAAA,IAGRL,SAASC,eAAe,cAAcoB,iBAAiB,SAAUC,IACzDvI,GACAsH,GAAA,G","sources":["src/catch-no-cv/catch.js"],"sourcesContent":["const gamejs = require('gamejs')\nconst pixelcollision = require('gamejs/src/gamejs/pixelcollision')\nconst vectors = require('gamejs/src/gamejs/math/vectors')\n\n\nclass Catch {\n\n    #deathCallback = function() {}\n    #winCallback = function() {}\n    #font = new gamejs.font.Font('200px monospace');\n    constructor(config, resources) {\n        this.config = config\n        this.resources = resources\n        this.#resetState()\n    }\n\n    #resetState() {\n        this.state = {\n            started: false,\n            elapsedMs: 0,\n            remainingLives: this.config.game.lives,\n            background: undefined,\n            catcher: undefined,\n            lives: [],\n            fallingItems: [],\n            speed: this.config.game.fallSpeed.initial,\n            score: 0,\n            level: 1,\n            itemsToSpawn: this.config.game.fallingItems.initial,\n            lastItemSpawnLevelUp: 1,\n            lastSpawn: null\n        }\n    }\n\n    setup() {\n        this.display = gamejs.display.getSurface()\n        this.size = this.display.getSize()\n        this.background = {\n            bg: gamejs.image.load(this.resources.background).scale(this.size),\n        }\n\n        this.state.background = this.background.bg\n    }\n\n    start() {\n        if(this.state.started) {\n            console.warn('Game alredy started!')\n            return\n        }\n\n        this.state.started = true\n\n        let catcherImg = gamejs.image.load(this.resources.catcher).scale(this.config.catcherSize)\n        this.state.catcher = {\n            img: catcherImg,\n            pos: [0, this.size[1] - 300],\n            mask: new pixelcollision.Mask(catcherImg)\n        }\n\n        for(let i =  0; i < this.state.remainingLives; i++) {\n            let x = (this.config.livesSize[1] * i) + 400\n            this.state.lives.push({\n                img: gamejs.image.load(this.resources.lives).scale(this.config.livesSize),\n                pos: [x, 20]\n            })\n        }\n\n        this.#spawnItem()\n    }\n\n    reset() {\n        this.#resetState()\n        this.setup()\n    }\n    \n    #lastEpoch = new Date().getTime()\n\n    onTick(msDuration) {\n        let newEpoch = new Date().getTime()\n        let diff = newEpoch - this.#lastEpoch\n        this.#lastEpoch = newEpoch\n    \n        if(diff < 15) {\n            return\n        }\n\n        this.state.elapsedMs += msDuration;\n        this.display.clear()\n\n        this.display.blit(this.state.background, [0, 0])\n        \n        this.display.blit(this.#font.render(`${this.state.score}`, '#fcecd3'), [this.size[0] - 200, 120]);\n\n        if(this.state.started) {\n            if(this.state.lives) {\n                this.state.lives.forEach(live => {\n                    this.display.blit(live.img, live.pos)    \n                });\n            }\n    \n            if(this.state.catcher) {\n                this.display.blit(this.state.catcher.img, this.state.catcher.pos)\n            }\n    \n            if(this.state.fallingItems) {\n\n                this.state.fallingItems.forEach((item, idx) => {\n                    item.pos = vectors.add(item.pos, [0, this.state.speed]);\n                    this.display.blit(item.img, item.pos)\n    \n                    if(this.#reachBottom(item.pos)) {\n                        this.state.fallingItems.splice(idx, 1)\n                        this.#die()\n                        if(this.state.remainingLives > 0) {\n                            this.#spawnItem()\n                        }\n                    }\n\n                    if(this.#recolected(item)) {\n                        this.state.fallingItems.splice(idx, 1)\n                        this.state.score++\n                        \n                        if(this.state.fallingItems.length === 0) {\n                            this.#spawnItem()\n                        }\n                    }\n                })\n            }\n    \n            this.#spawnItem()\n            this.#maybeLevelUp()\n            this.#checkWin()\n        }\n    }\n\n    #reachBottom(pos) {\n        return pos[1] >= this.size[1];\n    }\n\n    #recolected(item) {\n        if(this.state.catcher) {\n            let relativeOffset = vectors.subtract(this.state.catcher.pos, item.pos)\n            let hasMaskOverlap = this.state.catcher.mask.overlap(item.mask, relativeOffset)\n\n            return hasMaskOverlap\n        }\n\n        return false\n    }\n\n    #die() {\n        if(this.state.lives.length)\n            this.state.lives.splice(this.state.lives.length -1, 1)\n        this.state.remainingLives -= 1;\n\n        if(this.state.remainingLives === 0) {\n            this.#kill()\n        }\n    }\n\n    #spawnItem() {\n        if(this.state.fallingItems.length >= this.config.game.fallingItems.max)\n            return\n        \n        let now = new Date().getTime()\n        \n        if(this.state.lastSpawn) {\n            let diff = now - this.state.lastSpawn\n            if(this.config.game.fallingItems.newSpawnOffsetMs >= diff) return\n        }\n\n        for(let i = 0; i < this.state.itemsToSpawn; i++) {\n            if(this.state.fallingItems.length >= this.config.game.fallingItems.max)\n                return\n\n            this.state.lastSpawn = new Date().getTime()\n\n            let imgR = this.resources.fallingItems[Math.floor(Math.random()*this.resources.fallingItems.length)]\n        \n            let img = gamejs.image.load(imgR).scale(this.config.fallingItemsSize)\n\n            //let relativeOffset = vectors.subtract(this.state.catcher.pos, item.pos)\n            //let hasMaskOverlap = this.state.catcher.mask.overlap(item.mask, relativeOffset)\n\n            let newItemMask = new pixelcollision.Mask(img)\n            let spawnPos = this.#getPosition(newItemMask)\n\n            this.state.fallingItems.push({\n                img: img,\n                pos: spawnPos,\n                mask: newItemMask\n            })\n        }\n    }\n\n    #getPosition(newItemMask) {\n        let requiresRePositioning = false\n        let spawnPos = this.#getRandomXPos(this.config.fallingItemsSize[0])\n        \n        for(let j =  0; j < this.state.fallingItems.length; j++) {\n            let item = this.state.fallingItems[j]\n            let relativeOffset = vectors.subtract(spawnPos, item.pos)\n            \n            let hasMaskOverlap = this.state.catcher.mask.overlap(newItemMask, relativeOffset)\n\n            if(hasMaskOverlap) {\n                requiresRePositioning = true\n            }\n        }\n\n        if(requiresRePositioning) {\n            return this.#getPosition(newItemMask)\n        } else {\n            return spawnPos\n        }\n    }\n\n    #getRandomXPos(itemWidth) {\n        return [Math.floor(Math.random() * (this.size[0] - itemWidth)), 0]\n    }\n\n    #maybeLevelUp() {\n        let minElapsed = this.state.level * this.config.game.levelUpMs\n\n        let nextLevel = this.state.level + 1\n        if(this.state.elapsedMs >= minElapsed) {\n            this.state.level = nextLevel\n            this.state.speed = Math.min(this.state.speed+this.config.game.fallSpeed.step, this.config.game.fallSpeed.max)\n        }\n\n        if((this.state.level - this.state.lastItemSpawnLevelUp) >= this.config.game.fallingItems.levelUpStep) {\n            this.state.lastItemSpawnLevelUp = nextLevel\n            //this.state.itemsToSpawn = Math.min(this.state.itemsToSpawn+this.config.game.fallingItems.step, this.config.game.fallingItems.max)\n        }\n    }\n\n    #kill() {\n        this.started = false;\n        this.#deathCallback()\n        this.#resetState()\n        this.setup()\n    }\n\n    #checkWin() {\n        if(this.state.score >= this.config.game.winScore) {\n            this.started = false;\n            this.#winCallback()\n            this.#resetState()\n            this.setup()\n        }\n    }\n\n    onDeath(fn) {\n        this.#deathCallback = fn\n    }\n\n    onWin(fn) {\n        this.#winCallback = fn\n    }\n\n    moveCatcher(avgXPos) {\n        if(this.state.catcher)\n            this.state.catcher.pos[0] = Math.floor(this.size[0] * (1 - avgXPos))\n    }\n\n    moveCatcherStep(step) {\n        if(this.state.catcher) {\n            let newPos = Math.min(Math.max(0, this.state.catcher.pos[0] + step), this.size[0] - this.config.catcherSize[0])\n            this.state.catcher.pos[0] = newPos\n        }\n    }\n\n    moveCatcherMotion(pos) {\n        if(this.display.rect.collidePoint(pos)) {\n            this.state.catcher.pos[0] =  Math.min(Math.max(0, pos[0]), this.size[0] - this.config.catcherSize[0])\n        }\n    }\n}\n\nconst gameConfig = loadConfig('catch-no-cv', config);\n\nlet running = false;\n\nconst game = new Catch(gameConfig, resources)\n\nfunction hide(id) {\n    document.getElementById(id)\n        .classList.add(\"hidden\")  \n}\n\nfunction show(id) {\n    document.getElementById(id)\n        .classList.remove(\"hidden\")  \n}\n\nfunction destroy(id) {\n    document.getElementById(id).remove()\n}\n\nfunction startGame() {\n    running = true;\n    gamejs.preload([\n        resources.background,\n        resources.catcher,\n        resources.lives,\n        ...resources.fallingItems\n    ])\n\n    gamejs.event.onKeyDown(function(event) {\n        if(event.key === gamejs.event.K_LEFT) {\n            game.moveCatcherStep(-20)\n        }\n\n        if(event.key === gamejs.event.K_RIGHT) {\n            game.moveCatcherStep(20)\n        }\n    })\n\n    gamejs.event.onMouseMotion(function(event) {\n        game.moveCatcherMotion(event.pos)\n    })\n\n    gamejs.event.onTouchMotion(function(event) {\n        game.moveCatcherMotion(event.touches[0].pos)\n    })\n\n    gamejs.ready(function () {\n        hide('idle')\n        show('game')\n\n        gamejs.onTick(function(msDuration) {\n            game.onTick(msDuration)\n        })\n    \n        game.onDeath(function() { died() })\n        game.onWin(function() { win() })\n    \n        game.reset()\n        game.start()\n    })\n}\n\nfunction died() {\n    show('lose')\n    hide('game')\n    game.reset()\n\n    setTimeout(() => {\n        location.reload()\n    }, config.loseCooldownMs)\n}\n\nfunction win() {\n    show('win')\n    hide('game')\n    \n    game.reset()\n    running = false\n\n    setTimeout(() => {\n        location.reload()\n    }, gameConfig.winCooldownMs)\n}\n\ndocument.getElementById('start').addEventListener('click', (e) => {\n    if(!running)\n        startGame()\n});\n\ndocument.getElementById('start-text').addEventListener('click', (e) => {\n    if(!running)\n        startGame()\n});\n\n"],"names":["gamejs","require","pixelcollision","vectors","gameConfig","loadConfig","config","running","game","deathCallback","winCallback","font","Font","constructor","config1","resources1","this","resources","resetState","state","started","elapsedMs","remainingLives","lives","background","undefined","catcher","fallingItems","speed","fallSpeed","initial","score","level","itemsToSpawn","lastItemSpawnLevelUp","lastSpawn","setup","display","getSurface","size","getSize","bg","image","load","scale","start","console","warn","catcherImg","catcherSize","img","pos","mask","Mask","i","x","livesSize","push","spawnItem","reset","lastEpoch","Date","getTime","onTick","msDuration","newEpoch","diff","clear","blit","render","forEach","live","item","idx","add","reachBottom","splice","die","recolected","length","maybeLevelUp","checkWin","relativeOffset","subtract","overlap","kill","max","now","newSpawnOffsetMs","imgR","Math","floor","random","fallingItemsSize","newItemMask","spawnPos","getPosition","requiresRePositioning","getRandomXPos","j","itemWidth","minElapsed","levelUpMs","nextLevel","min","step","levelUpStep","winScore","onDeath","fn","onWin","moveCatcher","avgXPos","moveCatcherStep","newPos","moveCatcherMotion","rect","collidePoint","hide","id","document","getElementById","classList","show","remove","startGame","preload","event","onKeyDown","key","K_LEFT","K_RIGHT","onMouseMotion","onTouchMotion","touches","ready","setTimeout","location","reload","loseCooldownMs","winCooldownMs","addEventListener","e"],"version":3,"file":"index.f3bb1893.js.map"}